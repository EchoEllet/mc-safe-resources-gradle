package dev.echoellet.minecraft_safe_resources

import com.google.gson.JsonParser
import org.gradle.api.DefaultTask
import org.gradle.api.file.DirectoryProperty
import org.gradle.api.file.RegularFileProperty
import org.gradle.api.provider.Property
import org.gradle.api.tasks.Input
import org.gradle.api.tasks.InputFile
import org.gradle.api.tasks.OutputDirectory
import org.gradle.api.tasks.SkipWhenEmpty
import org.gradle.api.tasks.TaskAction
import java.io.File

/**
 * Generates a Java or Kotlin object that contains all the keys from a JSON file
 * to reference them in source code in a type-safe way.
 */
abstract class GenerateJsonKeysTask : DefaultTask() {
    @get:InputFile
    @get:SkipWhenEmpty
    abstract val inputResourceFile: RegularFileProperty

    @get:Input
    abstract val outputClassDescription: Property<String>

    @get:Input
    abstract val outputClassName: Property<String>

    @get:Input
    abstract val outputLanguage: Property<OutputLanguage>

    @get:Input
    abstract val outputPackage: Property<String>

    @get:Input
    abstract val keyNamespaceToStrip: Property<String>

    @get:Input
    abstract val useJetBrainsAnnotations: Property<Boolean>

    @get:OutputDirectory
    val genOutputDir: DirectoryProperty = project.objects.directoryProperty().convention(
        project.layout.buildDirectory.dir(
            project.provider {
                val langDir = when (outputLanguage.get()) {
                    OutputLanguage.JAVA -> "java"
                    OutputLanguage.KOTLIN -> "kotlin"
                }
                "generated/${name}/src/main/$langDir"
            }
        )
    )

    init {
        useJetBrainsAnnotations.convention(true)
        group = "generation"
    }

    @TaskAction
    fun generate() {
        description = outputClassDescription.get()
        val taskName = this.name

        val cachedInputResourceFile = inputResourceFile.get()

        val file = inputResourceFile.get().asFile
        if (!file.exists()) {
            error("The input resource file for the task '$taskName' does not exist: '${file.path}'")
        }
        val cachedOutputLang = outputLanguage.get()
        val cachedOutputClassName = outputClassName.get()
        val cachedOutputPackage = outputPackage.get()
        val cachedOutputClassDescription = outputClassDescription.get()

        val keys = parseKeys(file)

        val outputFile = genOutputDir.get().asFile
            .resolve(cachedOutputPackage.replace('.', '/'))
            .apply { mkdirs() }
            .resolve(getOutputFileName(cachedOutputClassName, cachedOutputLang))
        outputFile.parentFile.mkdirs()

        generateOutputClassFile(outputFile, keys, cachedOutputClassDescription, cachedOutputLang)

        logger.info("Generated `$cachedOutputClassName` from resource asset: ${cachedInputResourceFile.asFile.path}")
    }

    private fun getGeneratedConstantKeyLine(
        outputLanguage: OutputLanguage,
        constName: String,
        keyValue: String,
    ): String {
        return when (outputLanguage) {
            OutputLanguage.JAVA -> "public static final String $constName = \"$keyValue\";"
            OutputLanguage.KOTLIN -> "const val $constName = \"$keyValue\""
        }
    }

    private fun generateOutputClassFile(
        outputFile: File,
        keys: Map<String, String>,
        outputClassDescription: String,
        outputLanguage: OutputLanguage,
    ) {
        val generatedConstants = keys.map { (constName, keyValue) ->
            "    ${getGeneratedConstantKeyLine(outputLanguage, constName, keyValue)}"
        }
        val cachedOutputPackage = outputPackage.get()
        val cacheOutputClassName = outputClassName.get()
        val taskName = this.name

        val useJetBrainsAnnotations = useJetBrainsAnnotations.get()
        val fileText = buildString {
            when (outputLanguage) {
                OutputLanguage.JAVA -> {
                    appendLine("package $cachedOutputPackage;")
                    if (useJetBrainsAnnotations) {
                        appendLine()
                        appendLine("import org.jetbrains.annotations.ApiStatus;")
                    }
                    appendLine()
                    outputClassDescription.lines().forEach { line ->
                        appendLine("/// $line")
                    }
                    appendLine("///")
                    appendLine("/// This file is fully generated by Gradle scripts. DO NOT MODIFY DIRECTLY, as all changes will be overwritten.")
                    appendLine("/// Update the task `${taskName}` in `build.gradle.kts` OR `build.gradle` if needed.")
                    if (useJetBrainsAnnotations) {
                        appendLine("@ApiStatus.Internal")
                    }
                    appendLine("public final class $cacheOutputClassName {")
                    appendLine("    private $cacheOutputClassName() {")
                    appendLine("    }")
                    appendLine()
                    generatedConstants.forEach { appendLine(it) }
                    appendLine("}")
                }

                OutputLanguage.KOTLIN -> {
                    appendLine("package $cachedOutputPackage")
                    if (useJetBrainsAnnotations) {
                        appendLine()
                        appendLine("import org.jetbrains.annotations.ApiStatus")
                    }
                    appendLine()
                    appendLine("/**")
                    outputClassDescription.lines().forEach { line ->
                        appendLine(" * $line")
                    }
                    appendLine(" *")
                    appendLine(" * This file is fully generated by Gradle scripts. DO NOT MODIFY DIRECTLY, as all changes will be overwritten.")
                    appendLine(" * Update the task `${taskName}` in `build.gradle.kts` OR `build.gradle` if needed.")
                    appendLine(" */")
                    if (useJetBrainsAnnotations) {
                        appendLine("@ApiStatus.Internal")
                    }
                    appendLine("object $cacheOutputClassName {")
                    generatedConstants.forEach { appendLine(it) }
                    appendLine("}")
                }
            }
        }
        outputFile.writeText(fileText)
    }

    private fun parseKeys(file: File): Map<String, String> {
        val parser = JsonParser.parseString(file.readText())
        val modId = keyNamespaceToStrip.get()
        return parser.asJsonObject.entrySet().associate { (jsonKey, _) ->
            var constName = jsonKey
                // Remove mod id if present
                .replace(".$modId", "", ignoreCase = true)
                // Commonly used pattern in mods to avoid hardcoding the mod ID, example:
                // https://github.com/Exopandora/ShoulderSurfing/blob/c9fb6684e41cfe3970df76d1fc5724a4e14da14b/common/src/main/resources/assets/shouldersurfing/lang/en_us.json#L2
                .replace($$".${modId}", "", ignoreCase = true)
                .replace($$".${mod_id}", "", ignoreCase = true)
                // Convert camelCase to snake_case
                .replace(Regex("([a-z])([A-Z])"), "$1_$2")
                .replace(".", "_")
                // Replace any invalid characters with underscore to satisfy compilers
                .replace(Regex("[^A-Za-z0-9_]"), "_")
                .uppercase()

            // Prefix with underscore if starts with digit to satisfy compilers
            if (constName.firstOrNull()?.isDigit() == true) {
                constName = "_$constName"
            }

            // Escape $ to prevent Kotlin string interpolation; keep the literal JSON key
            val fieldName = if (outputLanguage.get() == OutputLanguage.KOTLIN) {
                jsonKey.replace("$", "\\$")
            } else jsonKey

            constName to fieldName
        }
    }

    private fun getOutputFileName(outputClassName: String, outputLanguage: OutputLanguage): String {
        return "${outputClassName}.${outputLanguage.fileExtension}"
    }
}
